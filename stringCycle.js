/**
 * 주어진 문자열에 대한 가장 짧은 주기를 반환해야 한다.
 * 예시: abababab → 2, abcabcabd → 9
 */

// 첫 번째 풀이 (최선의 풀이가 아님)
function stringCycle(s) {
  let cycle = "";

  for (const str of s) {
    cycle += str;
    const chunk = s.split(cycle);

    if (chunk.every((e) => e === "")) return cycle.length;
  }
}

// 두 번째 풀이 (해답을 참고한 풀이)
function stringCycle(s) {
  // 왜 n?
  // -> s 길이 자주 사용하니 가독성, 반복계산 피하기 위해 저장함
  // n 네이밍이 붙은 이유는 n이 문자열 길이를 나타내는 컨벤션(Number of characters)
  const n = s.length;

  // 왜 pi?, 0 채우는 방향으로 푸는 이유는?
  // -> pi[i]는 KMP 알고리즘에서 접두사와 접미사가 일차하는 가장 긴 길이를 저장하는 배열임
  // 초기엔 아무 것도 일치하지 않으니 모두 0으로 시작
  // pi 네이밍이 붙은 이유는 KMP 알고리즘에서 등장하는 공식용어(prefix info 혹은 prefix length라고 이해하면 됨)
  // 기존에 알고있던 3.14 그 파이 아님
  const pi = Array(n).fill(0);

  // j는 왜 있음?
  // -> 현재까지 일치한 접두사의 길이 나타내는 포인터
  let j = 0;

  for (let i = 1; i < n; i++) {
    // j가 1보다 크고 s[1]과 s[0]이 다르다면(접두사, 접미사가 연속적 일치가 끊어지면) 반복문 실행
    // 왜 이 조건? -> s[i], s[j]가 다르면, 이전 접두사 정보를 이용해서 j를 줄여나감(KMP 핵심)
    // j를 0부터 다시 비교하는 게 아니라 이미 알고 있는 정보로 건너뛰는 거임
    while (j > 0 && s[i] !== s[j]) {
      // j는 해당 pi의 요소 값 할당
      j = pi[j - 1];
    }

    // 현재 문자, 다음 문자가 같다면 (같은 문자가 이어진다면)
    // -> 일치하는 접두사, 접미사 길이가 1 증가한거임 그래서 pi에 그 정보 저장
    if (s[i] === s[j]) {
      // 현재 인덱스에 해당하는 pi의 요소에 1 증가한 j 할당
      pi[i] = ++j;
    }
  }
  // n(s의 길이)에서 pi의 마지막 요소를 뺀 값(정수) 할당
  // -> pi[n -1]은 전체 문자열에서 가장 긴 접두사, 접미사의 길이임
  // 이걸 n(전체 길이)에서 빼면 반복되는 문자열 주기의 길이가 나옴
  const len = n - pi[n - 1];

  // n을 len으로 나눈 나머지 값이 0이라면 len 반환, 아니라면 n 반환
  // -> n % len === 0은 반복 단위로 정확히 나눠진다는 뜻임
  // 아니라면 반복이 아니니까 최소 주기(전체 문자열의 길이)임
  return n % len === 0 ? len : n;
}
